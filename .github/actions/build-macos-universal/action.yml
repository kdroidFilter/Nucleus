name: Build macOS Universal Binary
description: Merge arm64 + x64 macOS .app bundles into a universal (fat) binary, then repackage as ZIP, DMG, and PKG

inputs:
  arm64-path:
    description: 'Directory containing the arm64 macOS artifacts (must include a *-arm64.zip)'
    required: true
  x64-path:
    description: 'Directory containing the x64 macOS artifacts (must include a *-x64.zip)'
    required: true
  output-path:
    description: 'Directory where universal artifacts will be written'
    required: false
    default: 'universal-output'

outputs:
  zip:
    description: 'Path to the universal ZIP'
    value: ${{ steps.build.outputs.zip }}
  dmg:
    description: 'Path to the universal DMG'
    value: ${{ steps.build.outputs.dmg }}
  pkg:
    description: 'Path to the universal PKG'
    value: ${{ steps.build.outputs.pkg }}

runs:
  using: composite
  steps:
    - name: Locate ZIP files
      id: locate
      shell: bash
      run: |
        set -euo pipefail

        ARM64_ZIP="$(find "${{ inputs.arm64-path }}" -name '*-arm64.zip' -type f | head -1)"
        X64_ZIP="$(find "${{ inputs.x64-path }}" -name '*-x64.zip' -type f | head -1)"

        if [[ -z "$ARM64_ZIP" ]]; then
          echo "::error::Could not find *-arm64.zip in ${{ inputs.arm64-path }}"
          find "${{ inputs.arm64-path }}" -type f >&2
          exit 1
        fi
        if [[ -z "$X64_ZIP" ]]; then
          echo "::error::Could not find *-x64.zip in ${{ inputs.x64-path }}"
          find "${{ inputs.x64-path }}" -type f >&2
          exit 1
        fi

        echo "arm64_zip=$ARM64_ZIP" >> "$GITHUB_OUTPUT"
        echo "x64_zip=$X64_ZIP" >> "$GITHUB_OUTPUT"

    - name: Build universal binary
      id: build
      shell: bash
      run: |
        set -euo pipefail

        ARM64_ZIP="${{ steps.locate.outputs.arm64_zip }}"
        X64_ZIP="${{ steps.locate.outputs.x64_zip }}"
        OUTPUT_DIR="${{ inputs.output-path }}"

        mkdir -p "$OUTPUT_DIR"

        # ── Derive universal artifact prefix from arm64 ZIP filename ──────────
        # e.g. NucleusDemo-1.0.0-mac-arm64.zip → NucleusDemo-1.0.0-mac-universal
        ARM64_BASENAME="$(basename "$ARM64_ZIP" .zip)"
        UNIVERSAL_PREFIX="$(echo "$ARM64_BASENAME" | sed -E 's/-(arm64|aarch64)$//')-universal"
        echo "==> Artifact prefix: $UNIVERSAL_PREFIX"

        # ── Temp dirs ─────────────────────────────────────────────────────────
        WORK="$(mktemp -d)"
        trap 'rm -rf "$WORK"' EXIT

        ARM64_DIR="$WORK/arm64"
        X64_DIR="$WORK/x64"
        UNIVERSAL_DIR="$WORK/universal"
        mkdir -p "$ARM64_DIR" "$X64_DIR" "$UNIVERSAL_DIR"

        # ── Extract ZIPs (ditto preserves macOS attributes) ───────────────────
        echo "==> Extracting arm64 ZIP: $ARM64_ZIP"
        ditto -x -k "$ARM64_ZIP" "$ARM64_DIR"

        echo "==> Extracting x64 ZIP: $X64_ZIP"
        ditto -x -k "$X64_ZIP" "$X64_DIR"

        # ── Locate .app bundles ───────────────────────────────────────────────
        ARM64_APP="$(find "$ARM64_DIR" -maxdepth 1 -name '*.app' -type d | head -1)"
        X64_APP="$(find "$X64_DIR" -maxdepth 1 -name '*.app' -type d | head -1)"

        if [[ -z "$ARM64_APP" || -z "$X64_APP" ]]; then
          echo "::error::Could not find .app bundles in extracted ZIPs"
          exit 1
        fi

        APP_NAME="$(basename "$ARM64_APP")"
        UNIVERSAL_APP="$UNIVERSAL_DIR/$APP_NAME"
        echo "==> App bundle: $APP_NAME"

        # ── Copy arm64 .app as base (preserves symlinks/hardlinks) ────────────
        echo "==> Copying arm64 .app as universal base"
        cp -a "$ARM64_APP" "$UNIVERSAL_APP"

        # ── Counters ──────────────────────────────────────────────────────────
        MERGED=0
        SKIPPED=0
        ARM64_ONLY=0
        X64_ONLY=0

        # ── Helper: check if a file is Mach-O ────────────────────────────────
        is_macho() {
          file -b "$1" 2>/dev/null | grep -q 'Mach-O'
        }

        # ── Helper: check if already a universal (fat) binary ─────────────────
        is_fat() {
          file -b "$1" 2>/dev/null | grep -q 'universal'
        }

        # ── Merge: scan arm64 base, fuse with x64 counterparts ───────────────
        echo "==> Scanning universal base for Mach-O binaries..."
        while IFS= read -r -d '' universal_file; do
          rel="${universal_file#"$UNIVERSAL_APP/"}"
          x64_file="$X64_APP/$rel"

          if ! is_macho "$universal_file"; then
            continue
          fi

          # Already a fat binary (e.g. bundled by upstream) — skip
          if is_fat "$universal_file"; then
            echo "  [SKIP] Already universal: $rel"
            ((SKIPPED++)) || true
            continue
          fi

          if [[ ! -f "$x64_file" ]]; then
            echo "  [WARN] arm64-only (no x64 counterpart): $rel"
            ((ARM64_ONLY++)) || true
            continue
          fi

          if ! is_macho "$x64_file"; then
            echo "  [WARN] x64 counterpart is not Mach-O, keeping arm64: $rel"
            ((ARM64_ONLY++)) || true
            continue
          fi

          # Fuse with lipo
          tmp_merged="$WORK/lipo_tmp"
          if ! lipo -create "$universal_file" "$x64_file" -output "$tmp_merged"; then
            echo "::error::lipo -create failed for: $rel"
            exit 1
          fi
          mv "$tmp_merged" "$universal_file"
          ((MERGED++)) || true

        done < <(find "$UNIVERSAL_APP" -type f -print0)

        # ── Reverse scan: find x64-only binaries missing from arm64 ───────────
        echo "==> Scanning x64 .app for binaries missing in arm64..."
        while IFS= read -r -d '' x64_file; do
          rel="${x64_file#"$X64_APP/"}"
          universal_file="$UNIVERSAL_APP/$rel"

          if [[ -f "$universal_file" ]]; then
            continue
          fi

          if ! is_macho "$x64_file"; then
            continue
          fi

          echo "  [WARN] x64-only binary, copying to universal bundle: $rel"
          mkdir -p "$(dirname "$universal_file")"
          cp -a "$x64_file" "$universal_file"
          ((X64_ONLY++)) || true

        done < <(find "$X64_APP" -type f -print0)

        echo ""
        echo "==> Merge summary: merged=$MERGED, skipped=$SKIPPED, arm64-only=$ARM64_ONLY, x64-only=$X64_ONLY"

        # ── Verify merged binaries ────────────────────────────────────────────
        echo "==> Verifying merged binaries with lipo -info..."
        while IFS= read -r -d '' f; do
          if is_macho "$f"; then
            info="$(lipo -info "$f" 2>&1)" || true
            echo "  $info"
          fi
        done < <(find "$UNIVERSAL_APP" -type f -print0)

        # ── Ad-hoc codesign ───────────────────────────────────────────────────
        echo "==> Ad-hoc signing universal .app bundle"
        codesign --force --deep --sign - "$UNIVERSAL_APP"

        # ── Create ZIP ────────────────────────────────────────────────────────
        ZIP_OUT="$OUTPUT_DIR/${UNIVERSAL_PREFIX}.zip"
        echo "==> Creating ZIP: $ZIP_OUT"
        ditto -c -k --keepParent "$UNIVERSAL_APP" "$ZIP_OUT"

        # ── Read packaging metadata from build artifacts ────────────────────
        METADATA_FILE="$(find "${{ inputs.arm64-path }}" -name 'packaging-metadata.json' -type f | head -1)"
        if [[ -z "$METADATA_FILE" ]]; then
          METADATA_FILE="$(find "${{ inputs.x64-path }}" -name 'packaging-metadata.json' -type f | head -1)"
        fi

        if [[ -n "$METADATA_FILE" ]]; then
          echo "==> Found packaging metadata: $METADATA_FILE"
          METADATA_DIR="$(dirname "$METADATA_FILE")"
          PRODUCT_NAME="$(python3 -c "import json; m=json.load(open('$METADATA_FILE')); print(m.get('productName') or '')")"
          APP_ID="$(python3 -c "import json; m=json.load(open('$METADATA_FILE')); print(m.get('appId') or '')")"
          COPYRIGHT="$(python3 -c "import json; m=json.load(open('$METADATA_FILE')); print(m.get('copyright') or '')")"
          ARTIFACT_NAME_TMPL="$(python3 -c "import json; m=json.load(open('$METADATA_FILE')); print(m.get('artifactName') or '')")"
          COMPRESSION="$(python3 -c "import json; m=json.load(open('$METADATA_FILE')); print(m.get('compression') or '')")"
          CATEGORY="$(python3 -c "import json; m=json.load(open('$METADATA_FILE')); print(m.get('category') or '')")"
          MIN_SYS_VERSION="$(python3 -c "import json; m=json.load(open('$METADATA_FILE')); print(m.get('minimumSystemVersion') or '')")"
          SIGN="$(python3 -c "import json; m=json.load(open('$METADATA_FILE')); print(str(m.get('sign', False)).lower())")"
          INSTALL_LOCATION="$(python3 -c "import json; m=json.load(open('$METADATA_FILE')); print(m.get('installLocation') or '')")"
          # DMG settings (file paths are relative to METADATA_DIR)
          DMG_SIGN="$(python3 -c "import json; m=json.load(open('$METADATA_FILE')); d=m.get('dmg',{}); print(str(d.get('sign', False)).lower())")"
          DMG_BACKGROUND_REL="$(python3 -c "import json; m=json.load(open('$METADATA_FILE')); d=m.get('dmg',{}); print(d.get('background') or '')")"
          DMG_BG_COLOR="$(python3 -c "import json; m=json.load(open('$METADATA_FILE')); d=m.get('dmg',{}); print(d.get('backgroundColor') or '')")"
          DMG_BADGE_ICON_REL="$(python3 -c "import json; m=json.load(open('$METADATA_FILE')); d=m.get('dmg',{}); print(d.get('badgeIcon') or '')")"
          DMG_ICON_REL="$(python3 -c "import json; m=json.load(open('$METADATA_FILE')); d=m.get('dmg',{}); print(d.get('icon') or '')")"
          DMG_ICON_SIZE="$(python3 -c "import json; m=json.load(open('$METADATA_FILE')); d=m.get('dmg',{}); v=d.get('iconSize'); print(v if v is not None else '')")"
          DMG_ICON_TEXT_SIZE="$(python3 -c "import json; m=json.load(open('$METADATA_FILE')); d=m.get('dmg',{}); v=d.get('iconTextSize'); print(v if v is not None else '')")"
          DMG_TITLE="$(python3 -c "import json; m=json.load(open('$METADATA_FILE')); d=m.get('dmg',{}); print(d.get('title') or '')")"
          DMG_FORMAT="$(python3 -c "import json; m=json.load(open('$METADATA_FILE')); d=m.get('dmg',{}); print(d.get('format') or '')")"
          DMG_INTERNET_ENABLED="$(python3 -c "import json; m=json.load(open('$METADATA_FILE')); d=m.get('dmg',{}); print(str(d.get('internetEnabled', False)).lower())")"
          DMG_WIN_X="$(python3 -c "import json; m=json.load(open('$METADATA_FILE')); d=m.get('dmg',{}); v=d.get('windowX'); print(v if v is not None else '')")"
          DMG_WIN_Y="$(python3 -c "import json; m=json.load(open('$METADATA_FILE')); d=m.get('dmg',{}); v=d.get('windowY'); print(v if v is not None else '')")"
          DMG_WIN_W="$(python3 -c "import json; m=json.load(open('$METADATA_FILE')); d=m.get('dmg',{}); v=d.get('windowWidth'); print(v if v is not None else '')")"
          DMG_WIN_H="$(python3 -c "import json; m=json.load(open('$METADATA_FILE')); d=m.get('dmg',{}); v=d.get('windowHeight'); print(v if v is not None else '')")"
          # Resolve relative asset paths to absolute
          DMG_BACKGROUND=""
          [[ -n "$DMG_BACKGROUND_REL" && -f "$METADATA_DIR/$DMG_BACKGROUND_REL" ]] && DMG_BACKGROUND="$METADATA_DIR/$DMG_BACKGROUND_REL"
          DMG_BADGE_ICON=""
          [[ -n "$DMG_BADGE_ICON_REL" && -f "$METADATA_DIR/$DMG_BADGE_ICON_REL" ]] && DMG_BADGE_ICON="$METADATA_DIR/$DMG_BADGE_ICON_REL"
          DMG_ICON=""
          [[ -n "$DMG_ICON_REL" && -f "$METADATA_DIR/$DMG_ICON_REL" ]] && DMG_ICON="$METADATA_DIR/$DMG_ICON_REL"
        else
          echo "==> No packaging metadata found, using defaults from Info.plist"
          PRODUCT_NAME=""
          APP_ID="$(defaults read "$UNIVERSAL_APP/Contents/Info" CFBundleIdentifier 2>/dev/null || echo "")"
          COPYRIGHT=""
          ARTIFACT_NAME_TMPL=""
          COMPRESSION=""
          CATEGORY=""
          MIN_SYS_VERSION=""
          SIGN="false"
          INSTALL_LOCATION=""
          DMG_SIGN="false"
          DMG_BACKGROUND=""
          DMG_BG_COLOR=""
          DMG_BADGE_ICON=""
          DMG_ICON=""
          DMG_ICON_SIZE=""
          DMG_ICON_TEXT_SIZE=""
          DMG_TITLE=""
          DMG_FORMAT=""
          DMG_INTERNET_ENABLED="false"
          DMG_WIN_X=""
          DMG_WIN_Y=""
          DMG_WIN_W=""
          DMG_WIN_H=""
        fi

        # Override artifactName to force universal suffix
        if [[ -n "$ARTIFACT_NAME_TMPL" ]]; then
          # Replace ${arch} with "universal" in the template
          UNIVERSAL_ARTIFACT_NAME="$(echo "$ARTIFACT_NAME_TMPL" | sed 's/\${arch}/universal/g')"
        else
          UNIVERSAL_ARTIFACT_NAME='${name}-${version}-${os}-universal.${ext}'
        fi

        # ── Generate electron-builder configs ─────────────────────────────────
        generate_eb_config() {
          local target_format="$1"
          local config_file="$2"

          {
            echo "directories:"
            echo "  output: ."
            [[ -n "$PRODUCT_NAME" ]] && echo "productName: \"$PRODUCT_NAME\""
            [[ -n "$APP_ID" ]] && echo "appId: \"$APP_ID\""
            [[ -n "$COPYRIGHT" ]] && echo "copyright: \"$COPYRIGHT\""
            [[ -n "$COMPRESSION" ]] && echo "compression: \"$COMPRESSION\""
            echo "artifactName: \"$UNIVERSAL_ARTIFACT_NAME\""
            echo "mac:"
            echo "  target:"
            echo "    - target: $target_format"
            [[ -n "$CATEGORY" ]] && echo "  category: \"$CATEGORY\""
            [[ -n "$MIN_SYS_VERSION" ]] && echo "  minimumSystemVersion: \"$MIN_SYS_VERSION\""
            if [[ "$SIGN" != "true" ]]; then
              echo "  identity: null"
              echo "  hardenedRuntime: false"
              echo "  gatekeeperAssess: false"
            fi
            if [[ "$target_format" == "dmg" ]]; then
              echo "dmg:"
              echo "  sign: $DMG_SIGN"
              [[ -n "$DMG_BACKGROUND" ]] && echo "  background: \"$DMG_BACKGROUND\""
              [[ -n "$DMG_BG_COLOR" ]] && echo "  backgroundColor: \"$DMG_BG_COLOR\""
              [[ -n "$DMG_BADGE_ICON" ]] && echo "  badgeIcon: \"$DMG_BADGE_ICON\""
              [[ -n "$DMG_ICON" ]] && echo "  icon: \"$DMG_ICON\""
              [[ -n "$DMG_ICON_SIZE" ]] && echo "  iconSize: $DMG_ICON_SIZE"
              [[ -n "$DMG_ICON_TEXT_SIZE" ]] && echo "  iconTextSize: $DMG_ICON_TEXT_SIZE"
              [[ -n "$DMG_TITLE" ]] && echo "  title: \"$DMG_TITLE\""
              [[ -n "$DMG_FORMAT" ]] && echo "  format: $DMG_FORMAT"
              [[ "$DMG_INTERNET_ENABLED" == "true" ]] && echo "  internetEnabled: true"
              if [[ -n "$DMG_WIN_X" || -n "$DMG_WIN_Y" || -n "$DMG_WIN_W" || -n "$DMG_WIN_H" ]]; then
                echo "  window:"
                [[ -n "$DMG_WIN_X" ]] && echo "    x: $DMG_WIN_X"
                [[ -n "$DMG_WIN_Y" ]] && echo "    y: $DMG_WIN_Y"
                [[ -n "$DMG_WIN_W" ]] && echo "    width: $DMG_WIN_W"
                [[ -n "$DMG_WIN_H" ]] && echo "    height: $DMG_WIN_H"
              fi
            elif [[ "$target_format" == "pkg" ]]; then
              echo "pkg:"
              [[ -n "$INSTALL_LOCATION" ]] && echo "  installLocation: \"$INSTALL_LOCATION\""
              echo "  isRelocatable: false"
              [[ "$SIGN" != "true" ]] && echo "  identity: null"
            fi
          } > "$config_file"

          echo "==> Generated electron-builder config for $target_format:"
          cat "$config_file"
        }

        generate_package_json() {
          echo "{ \"name\": \"$NPM_NAME\", \"version\": \"$BUNDLE_VERSION\", \"private\": true }" > "$1"
        }

        # ── Shared vars ───────────────────────────────────────────────────────
        NPM_NAME="$(echo "${PRODUCT_NAME:-app}" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9._-]/-/g' | sed 's/^-//;s/-$//')"
        BUNDLE_VERSION="$(defaults read "$UNIVERSAL_APP/Contents/Info" CFBundleShortVersionString 2>/dev/null || echo "1.0.0")"

        # ── Helper: update nucleus.executable.type in .cfg files ──────────
        update_executable_type() {
          local app_dir="$1"
          local exec_type="$2"
          local cfg_option="java-options=-Dnucleus.executable.type=$exec_type"
          local prefix="java-options=-Dnucleus.executable.type="

          find "$app_dir" -name '*.cfg' -not -name 'jvm.cfg' -type f | while IFS= read -r cfg; do
            if grep -q "$prefix" "$cfg"; then
              sed -i '' "s|${prefix}.*|${cfg_option}|" "$cfg"
              echo "  [CFG] Updated executable type to '$exec_type' in $(basename "$cfg")"
            fi
          done
        }

        run_electron_builder() {
          local format="$1"
          local eb_dir="$WORK/eb-$format"
          mkdir -p "$eb_dir"
          generate_package_json "$eb_dir/package.json"
          generate_eb_config "$format" "$eb_dir/electron-builder.yml" >&2

          # Update the executable type in .cfg before packaging
          update_executable_type "$UNIVERSAL_APP" "$format"

          CSC_IDENTITY_AUTO_DISCOVERY=false \
          npx --yes electron-builder \
            --prepackaged "$UNIVERSAL_APP" \
            --config "$eb_dir/electron-builder.yml" \
            --config.electronVersion=33.0.0 \
            --mac "$format" \
            --publish never \
            --project "$eb_dir" >&2 \
          || { echo "::error::electron-builder $format creation failed" >&2; exit 1; }

          local out_file="$(find "$eb_dir" -name "*.$format" -type f | head -1)"
          if [[ -n "$out_file" ]]; then
            cp "$out_file" "$OUTPUT_DIR/"
            echo "$OUTPUT_DIR/$(basename "$out_file")"
          fi
        }

        # ── Create DMG via electron-builder ───────────────────────────────────
        echo ""
        echo "==> Creating DMG via electron-builder..."
        DMG_OUT="$(run_electron_builder dmg)"
        [[ -n "$DMG_OUT" ]] && echo "==> DMG created: $DMG_OUT" || echo "::warning::electron-builder did not produce a DMG"

        # ── Create PKG via electron-builder ───────────────────────────────────
        echo ""
        echo "==> Creating PKG via electron-builder..."
        PKG_OUT="$(run_electron_builder pkg)"
        [[ -n "$PKG_OUT" ]] && echo "==> PKG created: $PKG_OUT" || echo "::warning::electron-builder did not produce a PKG"

        # ── Outputs ───────────────────────────────────────────────────────────
        echo ""
        echo "==> Universal artifacts created:"
        ls -lh "$OUTPUT_DIR"

        echo "zip=$ZIP_OUT" >> "$GITHUB_OUTPUT"
        echo "dmg=$DMG_OUT" >> "$GITHUB_OUTPUT"
        echo "pkg=$PKG_OUT" >> "$GITHUB_OUTPUT"
